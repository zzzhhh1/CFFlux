// é…ç½®
const CONFIG = {
  API_KEY: "xxx",  // å¯¹å¤–éªŒè¯key
  CF_ACCOUNT_LIST: [{ account_id: "xxx", token: "xxx" }],  // æ¢æˆè‡ªå·±çš„,å¯ä»¥å¤šä¸ªå·éšæœºè°ƒç”¨
  CF_IS_TRANSLATE: true,  // æ˜¯å¦å¯ç”¨æç¤ºè¯AIç¿»è¯‘åŠä¼˜åŒ–,å…³é—­åå°†ä¼šæŠŠæç¤ºè¯ç›´æ¥å‘é€ç»™ç»˜å›¾æ¨¡å‹
  CF_TRANSLATE_MODEL: "@cf/qwen/qwen1.5-14b-chat-awq",  // ä½¿ç”¨çš„cf aiæ¨¡å‹
  USE_EXTERNAL_API: false, // æ˜¯å¦ä½¿ç”¨è‡ªå®šä¹‰API,å¼€å¯åå°†ä½¿ç”¨å¤–éƒ¨æ¨¡å‹ç”Ÿæˆæç¤ºè¯,éœ€è¦å¡«å†™ä¸‹é¢ä¸‰é¡¹
  EXTERNAL_API: "", //è‡ªå®šä¹‰APIåœ°å€,ä¾‹å¦‚:https://xxx.com/v1/chat/completions
  EXTERNAL_MODEL: "", // æ¨¡å‹åç§°,ä¾‹å¦‚:gpt-4o
  EXTERNAL_API_KEY: "", // APIå¯†é’¥
  FLUX_NUM_STEPS: 4, // Fluxæ¨¡å‹çš„num_stepså‚æ•°,èŒƒå›´ï¼š4-8
  CUSTOMER_MODEL_MAP: {
//    "SD-1.5-Inpainting-CF": "@cf/runwayml/stable-diffusion-v1-5-inpainting",  // ä¸çŸ¥é“æ˜¯å“ªé‡Œæœ‰é—®é¢˜,å…ˆç¦ç”¨äº†
    "DS-8-CF": "@cf/lykon/dreamshaper-8-lcm",
    "SD-XL-Bash-CF": "@cf/stabilityai/stable-diffusion-xl-base-1.0",
    "SD-XL-Lightning-CF": "@cf/bytedance/stable-diffusion-xl-lightning",
    "FLUX.1-Schnell-CF": "@cf/black-forest-labs/flux-1-schnell"
  },
  IMAGE_EXPIRATION: 60 * 30 // å›¾ç‰‡åœ¨ KV ä¸­çš„è¿‡æœŸæ—¶é—´ï¼ˆç§’ï¼‰ï¼Œè¿™é‡Œè®¾ç½®ä¸º 30 åˆ†é’Ÿ
};

// ä¸»å¤„ç†å‡½æ•°
async function handleRequest(request) {
  if (request.method === "OPTIONS") {
    return handleCORS();
  }

  if (!isAuthorized(request)) {
    return new Response("Unauthorized", { status: 401 });
  }

  const url = new URL(request.url);
  if (url.pathname.endsWith("/v1/models")) {
    return handleModelsRequest();
  }

  if (request.method !== "POST" || !url.pathname.endsWith("/v1/chat/completions")) {
    return new Response("Not Found", { status: 404 });
  }

  return handleChatCompletions(request);
}

// å¤„ç†CORSé¢„æ£€è¯·æ±‚
function handleCORS() {
  return new Response(null, {
    status: 204,
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization'
    }
  });
}

// éªŒè¯æˆæƒ
function isAuthorized(request) {
  const authHeader = request.headers.get("Authorization");
  return authHeader && authHeader.startsWith("Bearer ") && authHeader.split(" ")[1] === CONFIG.API_KEY;
}

// å¤„ç†æ¨¡å‹åˆ—è¡¨è¯·æ±‚
function handleModelsRequest() {
  const models = Object.keys(CONFIG.CUSTOMER_MODEL_MAP).map(id => ({ id, object: "model" }));
  return new Response(JSON.stringify({ data: models, object: "list" }), {
    headers: {
      'Content-Type': 'application/json',
      'Access-Control-Allow-Origin': '*'
    }
  });
}

// å¤„ç†èŠå¤©å®Œæˆè¯·æ±‚
async function handleChatCompletions(request) {
  try {
    const data = await request.json();
    const { messages, model: requestedModel, stream } = data;
    const userMessage = messages.find(msg => msg.role === "user")?.content;

    if (!userMessage) {
      return new Response(JSON.stringify({ error: "æœªæ‰¾åˆ°ç”¨æˆ·æ¶ˆæ¯" }), { status: 400, headers: { 'Content-Type': 'application/json' } });
    }

    const isTranslate = extractTranslate(userMessage);
    const originalPrompt = cleanPromptString(userMessage);
    const model = CONFIG.CUSTOMER_MODEL_MAP[requestedModel] || CONFIG.CUSTOMER_MODEL_MAP["SD-XL-Lightning-CF"];

    // ç¡®å®šä½¿ç”¨å“ªä¸ªæ¨¡å‹ç”Ÿæˆæç¤ºè¯
    const promptModel = determinePromptModel();

    const translatedPrompt = isTranslate ? 
      (model === CONFIG.CUSTOMER_MODEL_MAP["FLUX.1-Schnell-CF"] ? 
        await getFluxPrompt(originalPrompt, promptModel) : 
        await getPrompt(originalPrompt, promptModel)) : 
      originalPrompt;

    const imageUrl = model === CONFIG.CUSTOMER_MODEL_MAP["FLUX.1-Schnell-CF"] ?
      await generateAndStoreFluxImage(model, translatedPrompt, request.url) :
      await generateAndStoreImage(model, translatedPrompt, request.url);

    return stream ? 
      handleStreamResponse(originalPrompt, translatedPrompt, "1024x1024", model, imageUrl, promptModel) :
      handleNonStreamResponse(originalPrompt, translatedPrompt, "1024x1024", model, imageUrl, promptModel);
  } catch (error) {
    return new Response(JSON.stringify({ error: "Internal Server Error: " + error.message }), { status: 500, headers: { 'Content-Type': 'application/json' } });
  }
}

function determinePromptModel() {
  return (CONFIG.USE_EXTERNAL_API && CONFIG.EXTERNAL_API && CONFIG.EXTERNAL_MODEL && CONFIG.EXTERNAL_API_KEY) ?
    CONFIG.EXTERNAL_MODEL : CONFIG.CF_TRANSLATE_MODEL;
}

// è·å–ç¿»è¯‘åçš„æç¤ºè¯
async function getPrompt(prompt, model) {
  const requestBody = {
    messages: [
      {
        role: "system",
        content: `ä½œä¸º Stable Diffusion Prompt æç¤ºè¯ä¸“å®¶ï¼Œæ‚¨å°†ä»å…³é”®è¯ä¸­åˆ›å»ºæç¤ºï¼Œé€šå¸¸æ¥è‡ª Danbooru ç­‰æ•°æ®åº“ã€‚

        æç¤ºé€šå¸¸æè¿°å›¾åƒï¼Œä½¿ç”¨å¸¸è§è¯æ±‡ï¼ŒæŒ‰é‡è¦æ€§æ’åˆ—ï¼Œå¹¶ç”¨é€—å·åˆ†éš”ã€‚é¿å…ä½¿ç”¨"-"æˆ–"."ï¼Œä½†å¯ä»¥æ¥å—ç©ºæ ¼å’Œè‡ªç„¶è¯­è¨€ã€‚é¿å…è¯æ±‡é‡å¤ã€‚

        ä¸ºäº†å¼ºè°ƒå…³é”®è¯ï¼Œè¯·å°†å…¶æ”¾åœ¨æ‹¬å·ä¸­ä»¥å¢åŠ å…¶æƒé‡ã€‚ä¾‹å¦‚ï¼Œ"(flowers)"å°†'flowers'çš„æƒé‡å¢åŠ 1.1å€ï¼Œè€Œ"(((flowers)))"å°†å…¶å¢åŠ 1.331å€ã€‚ä½¿ç”¨"(flowers:1.5)"å°†'flowers'çš„æƒé‡å¢åŠ 1.5å€ã€‚åªä¸ºé‡è¦çš„æ ‡ç­¾å¢åŠ æƒé‡ã€‚

        æç¤ºåŒ…æ‹¬ä¸‰ä¸ªéƒ¨åˆ†ï¼š**å‰ç¼€** ï¼ˆè´¨é‡æ ‡ç­¾+é£æ ¼è¯+æ•ˆæœå™¨ï¼‰+ **ä¸»é¢˜** ï¼ˆå›¾åƒçš„ä¸»è¦ç„¦ç‚¹ï¼‰+ **åœºæ™¯** ï¼ˆèƒŒæ™¯ã€ç¯å¢ƒï¼‰ã€‚

        *   å‰ç¼€å½±å“å›¾åƒè´¨é‡ã€‚åƒ"masterpiece"ã€"best quality"ã€"4k"è¿™æ ·çš„æ ‡ç­¾å¯ä»¥æé«˜å›¾åƒçš„ç»†èŠ‚ã€‚åƒ"illustration"ã€"lensflare"è¿™æ ·çš„é£æ ¼è¯å®šä¹‰å›¾åƒçš„é£æ ¼ã€‚åƒ"bestlighting"ã€"lensflare"ã€"depthoffield"è¿™æ ·çš„æ•ˆæœå™¨ä¼šå½±å“å…‰ç…§å’Œæ·±åº¦ã€‚

        *   ä¸»é¢˜æ˜¯å›¾åƒçš„ä¸»è¦ç„¦ç‚¹ï¼Œå¦‚è§’è‰²æˆ–åœºæ™¯ã€‚å¯¹ä¸»é¢˜è¿›è¡Œè¯¦ç»†æè¿°å¯ä»¥ç¡®ä¿å›¾åƒä¸°å¯Œè€Œè¯¦ç»†ã€‚å¢åŠ ä¸»é¢˜çš„æƒé‡ä»¥å¢å¼ºå…¶æ¸…æ™°åº¦ã€‚å¯¹äºè§’è‰²ï¼Œæè¿°é¢éƒ¨ã€å¤´å‘ã€èº«ä½“ã€æœè£…ã€å§¿åŠ¿ç­‰ç‰¹å¾ã€‚

        *   åœºæ™¯æè¿°ç¯å¢ƒã€‚æ²¡æœ‰åœºæ™¯ï¼Œå›¾åƒçš„èƒŒæ™¯æ˜¯å¹³æ·¡çš„ï¼Œä¸»é¢˜æ˜¾å¾—è¿‡å¤§ã€‚æŸäº›ä¸»é¢˜æœ¬èº«åŒ…å«åœºæ™¯ï¼ˆä¾‹å¦‚å»ºç­‘ç‰©ã€é£æ™¯ï¼‰ã€‚åƒ"èŠ±è‰è‰åœ°"ã€"é˜³å…‰"ã€"æ²³æµ"è¿™æ ·çš„ç¯å¢ƒè¯å¯ä»¥ä¸°å¯Œåœºæ™¯ã€‚ä½ çš„ä»»åŠ¡æ˜¯è®¾è®¡å›¾åƒç”Ÿæˆçš„æç¤ºã€‚è¯·æŒ‰ç…§ä»¥ä¸‹æ­¥éª¤è¿›è¡Œæ“ä½œï¼š

        1.  æˆ‘ä¼šå‘é€ç»™æ‚¨ä¸€ä¸ªå›¾åƒåœºæ™¯ã€‚éœ€è¦ä½ ç”Ÿæˆè¯¦ç»†çš„å›¾åƒæè¿°
        2.  å›¾åƒæè¿°å¿…é¡»æ˜¯è‹±æ–‡ï¼Œè¾“å‡ºä¸ºPositive Promptã€‚

        ç¤ºä¾‹ï¼š

        æˆ‘å‘é€ï¼šäºŒæˆ˜æ—¶æœŸçš„æŠ¤å£«ã€‚
        æ‚¨å›å¤åªå›å¤ï¼š
        A WWII-era nurse in a German uniform, holding a wine bottle and stethoscope, sitting at a table in white attire, with a table in the background, masterpiece, best quality, 4k, illustration style, best lighting, depth of field, detailed character, detailed environment.`
      },
      { role: "user", content: prompt }
    ],
    model: CONFIG.EXTERNAL_MODEL
  };

  if (model === CONFIG.EXTERNAL_MODEL) {
    return await getExternalPrompt(requestBody);
  } else {
    return await getCloudflarePrompt(CONFIG.CF_TRANSLATE_MODEL, requestBody);
  }
}

// è·å– Flux æ¨¡å‹çš„ç¿»è¯‘åçš„æç¤ºè¯
async function getFluxPrompt(prompt, model) {
  const requestBody = {
    messages: [
      {
        role: "system",
        content: `ä½ æ˜¯ä¸€ä¸ªåŸºäºFlux.1æ¨¡å‹çš„æç¤ºè¯ç”Ÿæˆæœºå™¨äººã€‚æ ¹æ®ç”¨æˆ·çš„éœ€æ±‚ï¼Œè‡ªåŠ¨ç”Ÿæˆç¬¦åˆFlux.1æ ¼å¼çš„ç»˜ç”»æç¤ºè¯ã€‚è™½ç„¶ä½ å¯ä»¥å‚è€ƒæä¾›çš„æ¨¡æ¿æ¥å­¦ä¹ æç¤ºè¯ç»“æ„å’Œè§„å¾‹ï¼Œä½†ä½ å¿…é¡»å…·å¤‡çµæ´»æ€§æ¥åº”å¯¹å„ç§ä¸åŒéœ€æ±‚ã€‚æœ€ç»ˆè¾“å‡ºåº”ä»…é™æç¤ºè¯ï¼Œæ— éœ€ä»»ä½•å…¶ä»–è§£é‡Šæˆ–ä¿¡æ¯ã€‚ä½ çš„å›ç­”å¿…é¡»å…¨éƒ¨ä½¿ç”¨è‹±è¯­è¿›è¡Œå›å¤æˆ‘ï¼

### **æç¤ºè¯ç”Ÿæˆé€»è¾‘**ï¼š

1. **éœ€æ±‚è§£æ**ï¼šä»ç”¨æˆ·çš„æè¿°ä¸­æå–å…³é”®ä¿¡æ¯ï¼ŒåŒ…æ‹¬ï¼š
   - è§’è‰²ï¼šå¤–è²Œã€åŠ¨ä½œã€è¡¨æƒ…ç­‰ã€‚
   - åœºæ™¯ï¼šç¯å¢ƒã€å…‰çº¿ã€å¤©æ°”ç­‰ã€‚
   - é£æ ¼ï¼šè‰ºæœ¯é£æ ¼ã€æƒ…æ„Ÿæ°›å›´ã€é…è‰²ç­‰ã€‚
   - å…¶ä»–å…ƒç´ ï¼šç‰¹å®šç‰©å“ã€èƒŒæ™¯æˆ–ç‰¹æ•ˆã€‚

2. **æç¤ºè¯ç»“æ„è§„å¾‹**ï¼š
   - **ç®€æ´ã€ç²¾ç¡®ä¸”å…·è±¡**ï¼šæç¤ºè¯éœ€è¦ç®€å•ã€æ¸…æ™°åœ°æè¿°æ ¸å¿ƒå¯¹è±¡ï¼Œå¹¶åŒ…å«è¶³å¤Ÿç»†èŠ‚ä»¥å¼•å¯¼ç”Ÿæˆå‡ºç¬¦åˆéœ€æ±‚çš„å›¾åƒã€‚
   - **çµæ´»å¤šæ ·**ï¼šå‚è€ƒä¸‹åˆ—æ¨¡æ¿å’Œå·²æœ‰ç¤ºä¾‹ï¼Œä½†éœ€æ ¹æ®å…·ä½“éœ€æ±‚ç”Ÿæˆå¤šæ ·åŒ–çš„æç¤ºè¯ï¼Œé¿å…å›ºå®šåŒ–æˆ–è¿‡äºä¾èµ–æ¨¡æ¿ã€‚
   - **ç¬¦åˆFlux.1é£æ ¼çš„æè¿°**ï¼šæç¤ºè¯å¿…é¡»éµå¾ªFlux.1çš„è¦æ±‚ï¼Œå°½é‡åŒ…å«è‰ºæœ¯é£æ ¼ã€è§†è§‰æ•ˆæœã€æƒ…æ„Ÿæ°›å›´çš„æè¿°ï¼Œä½¿ç”¨ä¸Flux.1æ¨¡å‹ç”Ÿæˆç›¸ç¬¦çš„å…³é”®è¯å’Œæè¿°æ¨¡å¼ã€‚

3. **ä»…ä¾›ä½ å‚è€ƒå’Œå­¦ä¹ çš„å‡ ç§åœºæ™¯æç¤ºè¯**ï¼ˆä½ éœ€è¦å­¦ä¹ å¹¶çµæ´»è°ƒæ•´,"[ ]"ä¸­å†…å®¹è§†ç”¨æˆ·é—®é¢˜è€Œå®šï¼‰ï¼š
   - **è§’è‰²è¡¨æƒ…é›†**ï¼š
åœºæ™¯è¯´æ˜ï¼šé€‚åˆåŠ¨ç”»æˆ–æ¼«ç”»åˆ›ä½œè€…ä¸ºè§’è‰²è®¾è®¡å¤šæ ·çš„è¡¨æƒ…ã€‚è¿™äº›æç¤ºè¯å¯ä»¥ç”Ÿæˆå±•ç¤ºåŒä¸€è§’è‰²åœ¨ä¸åŒæƒ…ç»ªä¸‹çš„è¡¨æƒ…é›†ï¼Œæ¶µç›–å¿«ä¹ã€æ‚²ä¼¤ã€æ„¤æ€’ç­‰å¤šç§æƒ…æ„Ÿã€‚

æç¤ºè¯ï¼šAn anime [SUBJECT], animated expression reference sheet, character design, reference sheet, turnaround, lofi style, soft colors, gentle natural linework, key art, range of emotions, happy sad mad scared nervous embarrassed confused neutral, hand drawn, award winning anime, fully clothed

[SUBJECT] character, animation expression reference sheet with several good animation expressions featuring the same character in each one, showing different faces from the same person in a grid pattern: happy sad mad scared nervous embarrassed confused neutral, super minimalist cartoon style flat muted kawaii pastel color palette, soft dreamy backgrounds, cute round character designs, minimalist facial features, retro-futuristic elements, kawaii style, space themes, gentle line work, slightly muted tones, simple geometric shapes, subtle gradients, oversized clothing on characters, whimsical, soft puffy art, pastels, watercolor

   - **å…¨è§’åº¦è§’è‰²è§†å›¾**ï¼š
åœºæ™¯è¯´æ˜ï¼šå½“éœ€è¦ä»ç°æœ‰è§’è‰²è®¾è®¡ä¸­ç”Ÿæˆä¸åŒè§’åº¦çš„å…¨èº«å›¾æ—¶ï¼Œå¦‚æ­£é¢ã€ä¾§é¢å’ŒèƒŒé¢ï¼Œé€‚ç”¨äºè§’è‰²è®¾è®¡ç»†åŒ–æˆ–åŠ¨ç”»å»ºæ¨¡ã€‚

æç¤ºè¯ï¼šA character sheet of [SUBJECT] in different poses and angles, including front view, side view, and back view

   - **80 å¹´ä»£å¤å¤é£æ ¼**ï¼š
åœºæ™¯è¯´æ˜ï¼šé€‚åˆå¸Œæœ›åˆ›é€  80 å¹´ä»£å¤å¤é£æ ¼ç…§ç‰‡æ•ˆæœçš„è‰ºæœ¯å®¶æˆ–è®¾è®¡å¸ˆã€‚è¿™äº›æç¤ºè¯å¯ä»¥ç”Ÿæˆå¸¦æœ‰æ€€æ—§æ„Ÿçš„æ¨¡ç³Šå®ä¸½æ¥é£æ ¼ç…§ç‰‡ã€‚

æç¤ºè¯ï¼šblurry polaroid of [a simple description of the scene], 1980s.

   - **æ™ºèƒ½æ‰‹æœºå†…éƒ¨å±•ç¤º**ï¼š
åœºæ™¯è¯´æ˜ï¼šé€‚åˆéœ€è¦å±•ç¤ºæ™ºèƒ½æ‰‹æœºç­‰äº§å“è®¾è®¡çš„ç§‘æŠ€åšå®¢ä½œè€…æˆ–äº§å“è®¾è®¡å¸ˆã€‚è¿™äº›æç¤ºè¯å¸®åŠ©ç”Ÿæˆå±•ç¤ºæ‰‹æœºå¤–è§‚å’Œå±å¹•å†…å®¹çš„å›¾åƒã€‚

æç¤ºè¯ï¼ša iphone product image showing the iphone standing and inside the screen the image is shown

   - **åŒé‡æ›å…‰æ•ˆæœ**ï¼š
åœºæ™¯è¯´æ˜ï¼šé€‚åˆæ‘„å½±å¸ˆæˆ–è§†è§‰è‰ºæœ¯å®¶é€šè¿‡åŒé‡æ›å…‰æŠ€æœ¯åˆ›é€ æ·±åº¦å’Œæƒ…æ„Ÿè¡¨è¾¾çš„è‰ºæœ¯ä½œå“ã€‚

æç¤ºè¯ï¼š[Abstract style waterfalls, wildlife] inside the silhouette of a [man]â€™s head that is a double exposure photograph . Non-representational, colors and shapes, expression of feelings, imaginative, highly detailed

   - **é«˜è´¨æ„Ÿç”µå½±æµ·æŠ¥**ï¼š
åœºæ™¯è¯´æ˜ï¼šé€‚åˆéœ€è¦ä¸ºç”µå½±åˆ›å»ºå¼•äººæ³¨ç›®æµ·æŠ¥çš„ç”µå½±å®£ä¼ æˆ–å¹³é¢è®¾è®¡å¸ˆã€‚

æç¤ºè¯ï¼šA digital illustration of a movie poster titled [â€˜Sad Sax: Fury Toadâ€™], [Mad Max] parody poster, featuring [a saxophone-playing toad in a post-apocalyptic desert, with a customized car made of musical instruments], in the background, [a wasteland with other musical vehicle chases], movie title in [a gritty, bold font, dusty and intense color palette].

   - **é•œé¢è‡ªæ‹æ•ˆæœ**ï¼š
åœºæ™¯è¯´æ˜ï¼šé€‚åˆæƒ³è¦æ•æ‰æ—¥å¸¸ç”Ÿæ´»ç¬é—´çš„æ‘„å½±å¸ˆæˆ–ç¤¾äº¤åª’ä½“ç”¨æˆ·ã€‚

æç¤ºè¯ï¼šPhone photo: A woman stands in front of a mirror, capturing a selfie. The image quality is grainy, with a slight blur softening the details. The lighting is dim, casting shadows that obscure her features. [The room is cluttered, with clothes strewn across the bed and an unmade blanket. Her expression is casual, full of concentration], while the old iPhone struggles to focus, giving the photo an authentic, unpolished feel. The mirror shows smudges and fingerprints, adding to the raw, everyday atmosphere of the scene.

   - **åƒç´ è‰ºæœ¯åˆ›ä½œ**ï¼š
åœºæ™¯è¯´æ˜ï¼šé€‚åˆåƒç´ è‰ºæœ¯çˆ±å¥½è€…æˆ–å¤å¤æ¸¸æˆå¼€å‘è€…åˆ›é€ æˆ–å¤åˆ»ç»å…¸åƒç´ é£æ ¼å›¾åƒã€‚

æç¤ºè¯ï¼š[Anything you want] pixel art style, pixels, pixel art

   - **ä»¥ä¸Šéƒ¨åˆ†åœºæ™¯ä»…ä¾›ä½ å­¦ä¹ ï¼Œä¸€å®šè¦å­¦ä¼šçµæ´»å˜é€šï¼Œä»¥é€‚åº”ä»»ä½•ç»˜ç”»éœ€æ±‚**ï¼š

4. **Flux.1æç¤ºè¯è¦ç‚¹æ€»ç»“**ï¼š
   - **ç®€æ´ç²¾å‡†çš„ä¸»ä½“æè¿°**ï¼šæ˜ç¡®å›¾åƒä¸­æ ¸å¿ƒå¯¹è±¡çš„èº«ä»½æˆ–åœºæ™¯ã€‚
   - **é£æ ¼å’Œæƒ…æ„Ÿæ°›å›´çš„å…·ä½“æè¿°**ï¼šç¡®ä¿æç¤ºè¯åŒ…å«è‰ºæœ¯é£æ ¼ã€å…‰çº¿ã€é…è‰²ã€ä»¥åŠå›¾åƒçš„æ°›å›´ç­‰ä¿¡æ¯ã€‚
   - **åŠ¨æ€ä¸ç»†èŠ‚çš„è¡¥å……**ï¼šæç¤ºè¯å¯åŒ…æ‹¬åœºæ™¯ä¸­çš„åŠ¨ä½œã€æƒ…ç»ªã€æˆ–å…‰å½±æ•ˆæœç­‰é‡è¦ç»†èŠ‚ã€‚
   - **å…¶ä»–æ›´å¤šè§„å¾‹è¯·è‡ªå·±å¯»æ‰¾**
---

**é—®ç­”æ¡ˆä¾‹1**ï¼š
**ç”¨æˆ·è¾“å…¥**ï¼šä¸€ä¸ª80å¹´ä»£å¤å¤é£æ ¼çš„ç…§ç‰‡ã€‚
**ä½ çš„è¾“å‡º**ï¼šA blurry polaroid of a 1980s living room, with vintage furniture, soft pastel tones, and a nostalgic, grainy texture,  The sunlight filters through old curtains, casting long, warm shadows on the wooden floor, 1980s,

**é—®ç­”æ¡ˆä¾‹2**ï¼š
**ç”¨æˆ·è¾“å…¥**ï¼šä¸€ä¸ªèµ›åšæœ‹å…‹é£æ ¼çš„å¤œæ™šåŸå¸‚èƒŒæ™¯
**ä½ çš„è¾“å‡º**ï¼šA futuristic cityscape at night, in a cyberpunk style, with neon lights reflecting off wet streets, towering skyscrapers, and a glowing, high-tech atmosphere. Dark shadows contrast with vibrant neon signs, creating a dramatic, dystopian mood`
      },
      { role: "user", content: prompt }
    ],
    model: CONFIG.EXTERNAL_MODEL
  };

  if (model === CONFIG.EXTERNAL_MODEL) {
    return await getExternalPrompt(requestBody);
  } else {
    return await getCloudflarePrompt(CONFIG.CF_TRANSLATE_MODEL, requestBody);
  }
}

// ä»å¤–éƒ¨APIè·å–æç¤ºè¯
async function getExternalPrompt(requestBody) {
  try {
    const response = await fetch(CONFIG.EXTERNAL_API, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${CONFIG.EXTERNAL_API_KEY}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(requestBody)
    });

    if (!response.ok) {
      throw new Error(`External API request failed with status ${response.status}`);
    }

    const jsonResponse = await response.json();
    if (!jsonResponse.choices || jsonResponse.choices.length === 0 || !jsonResponse.choices[0].message) {
      throw new Error('Invalid response format from external API');
    }

    return jsonResponse.choices[0].message.content;
  } catch (error) {
    console.error('Error in getExternalPrompt:', error);
 // å¦‚æœå¤–éƒ¨APIå¤±è´¥ï¼Œå›é€€åˆ°ä½¿ç”¨åŸå§‹æç¤ºè¯
    return requestBody.messages[1].content;
  }
}

// ä»Cloudflareè·å–æç¤ºè¯
async function getCloudflarePrompt(model, requestBody) {
  const response = await postRequest(model, requestBody);
  if (!response.ok) return requestBody.messages[1].content;

  const jsonResponse = await response.json();
  return jsonResponse.result.response;
}

// ç”Ÿæˆå›¾åƒå¹¶å­˜å‚¨åˆ° KV
async function generateAndStoreImage(model, prompt, requestUrl) {
  try {
    const jsonBody = { prompt, num_steps: 20, guidance: 7.5, strength: 1, width: 1024, height: 1024 };
    const response = await postRequest(model, jsonBody);
    const imageBuffer = await response.arrayBuffer();

    const key = `image_${Date.now()}_${Math.random().toString(36).substring(7)}`;
    
    await IMAGE_KV.put(key, imageBuffer, {
      expirationTtl: CONFIG.IMAGE_EXPIRATION,
      metadata: { contentType: 'image/png' }
    });

    return `${new URL(requestUrl).origin}/image/${key}`;
  } catch (error) {
    throw new Error("å›¾åƒç”Ÿæˆå¤±è´¥: " + error.message);
  }
}

// ä½¿ç”¨ Flux æ¨¡å‹ç”Ÿæˆå¹¶å­˜å‚¨å›¾åƒ
async function generateAndStoreFluxImage(model, prompt, requestUrl) {
  try {
    const jsonBody = { prompt, num_steps: CONFIG.FLUX_NUM_STEPS };
    const response = await postRequest(model, jsonBody);
    const jsonResponse = await response.json();
    const base64ImageData = jsonResponse.result.image;

    const imageBuffer = base64ToArrayBuffer(base64ImageData);

    const key = `image_${Date.now()}_${Math.random().toString(36).substring(7)}`;

    await IMAGE_KV.put(key, imageBuffer, {
      expirationTtl: CONFIG.IMAGE_EXPIRATION,
      metadata: { contentType: 'image/png' }
    });

    return `${new URL(requestUrl).origin}/image/${key}`;
  } catch (error) {
    throw new Error("Fluxå›¾åƒç”Ÿæˆå¤±è´¥: " + error.message);
  }
}

// å¤„ç†æµå¼å“åº”
function handleStreamResponse(originalPrompt, translatedPrompt, size, model, imageUrl, promptModel) {
  const content = generateResponseContent(originalPrompt, translatedPrompt, size, model, imageUrl, promptModel);
  const encoder = new TextEncoder();
  const stream = new ReadableStream({
    start(controller) {
      controller.enqueue(encoder.encode(`data: ${JSON.stringify({
        id: `chatcmpl-${Date.now()}`,
        object: "chat.completion.chunk",
        created: Math.floor(Date.now() / 1000),
        model: model,
        choices: [{ delta: { content: content }, index: 0, finish_reason: null }]
      })}\n\n`));
      controller.enqueue(encoder.encode('data: [DONE]\n\n'));
      controller.close();
    }
  });

  return new Response(stream, {
    headers: {
      "Content-Type": "text/event-stream",
      'Access-Control-Allow-Origin': '*',
      "Cache-Control": "no-cache",
      "Connection": "keep-alive"
    }
  });
}

// å¤„ç†éæµå¼å“åº”
function handleNonStreamResponse(originalPrompt, translatedPrompt, size, model, imageUrl, promptModel) {
  const content = generateResponseContent(originalPrompt, translatedPrompt, size, model, imageUrl, promptModel);
  const response = {
    id: `chatcmpl-${Date.now()}`,
    object: "chat.completion",
    created: Math.floor(Date.now() / 1000),
    model: model,
    choices: [{
      index: 0,
      message: { role: "assistant", content },
      finish_reason: "stop"
    }],
    usage: {
      prompt_tokens: translatedPrompt.length,
      completion_tokens: content.length,
      total_tokens: translatedPrompt.length + content.length
    }
  };

  return new Response(JSON.stringify(response), {
    headers: {
      'Content-Type': 'application/json',
      'Access-Control-Allow-Origin': '*'
    }
  });
}

// ç”Ÿæˆå“åº”å†…å®¹
function generateResponseContent(originalPrompt, translatedPrompt, size, model, imageUrl, promptModel) {
  return `ğŸ¨ åŸå§‹æç¤ºè¯ï¼š${originalPrompt}\n` +
         `ğŸ’¬ æç¤ºè¯ç”Ÿæˆæ¨¡å‹ï¼š${promptModel}\n` +
         `ğŸŒ ç¿»è¯‘åçš„æç¤ºè¯ï¼š${translatedPrompt}\n` +
         `ğŸ“ å›¾åƒè§„æ ¼ï¼š${size}\n` +
         `ğŸ–¼ï¸ ç»˜å›¾æ¨¡å‹ï¼š${model}\n` +
         `ğŸŒŸ å›¾åƒç”ŸæˆæˆåŠŸï¼\n` +
         `ä»¥ä¸‹æ˜¯ç»“æœï¼š\n\n` +
         `![ç”Ÿæˆçš„å›¾åƒ](${imageUrl})`;
}

// å‘é€POSTè¯·æ±‚
async function postRequest(model, jsonBody) {
  const cf_account = CONFIG.CF_ACCOUNT_LIST[Math.floor(Math.random() * CONFIG.CF_ACCOUNT_LIST.length)];
  const apiUrl = `https://api.cloudflare.com/client/v4/accounts/${cf_account.account_id}/ai/run/${model}`;
  const response = await fetch(apiUrl, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${cf_account.token}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(jsonBody)
  });

  if (!response.ok) {
    throw new Error('Cloudflare API request failed: ' + response.status);
  }
  return response;
}

// æå–ç¿»è¯‘æ ‡å¿—
function extractTranslate(prompt) {
  const match = prompt.match(/---n?tl/);
  return match ? match[0] === "---tl" : CONFIG.CF_IS_TRANSLATE;
}

// æ¸…ç†æç¤ºè¯å­—ç¬¦ä¸²
function cleanPromptString(prompt) {
  return prompt.replace(/---n?tl/, "").trim();
}

// å¤„ç†å›¾ç‰‡è¯·æ±‚
async function handleImageRequest(request) {
  const url = new URL(request.url);
  const key = url.pathname.split('/').pop();
  
  const imageData = await IMAGE_KV.get(key, 'arrayBuffer');
  if (!imageData) {
    return new Response('Image not found', { status: 404 });
  }

  return new Response(imageData, {
    headers: {
      'Content-Type': 'image/png',
      'Cache-Control': 'public, max-age=604800',
    },
  });
}

// base64 å­—ç¬¦ä¸²è½¬æ¢ä¸º ArrayBuffer
function base64ToArrayBuffer(base64) {
  const binaryString = atob(base64);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes.buffer;
}

addEventListener('fetch', event => {
  const url = new URL(event.request.url);
  if (url.pathname.startsWith('/image/')) {
    event.respondWith(handleImageRequest(event.request));
  } else {
    event.respondWith(handleRequest(event.request));
  }
});